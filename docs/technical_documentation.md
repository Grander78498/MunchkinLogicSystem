# Техническая документация SHLDN

## Архитектура системы

SHLDN следует классической архитектуре компиляторов и интерпретаторов, состоящей из нескольких этапов обработки:

1. **Лексический анализ** - токенизация входного текста
2. **Синтаксический анализ** - построение абстрактного синтаксического дерева (AST)
3. **Семантический анализ** - преобразование AST в модели данных
4. **Логическая обработка** - применение методов логического программирования
5. **Выполнение** - интерпретация команд и доказательство теорем

## Компоненты системы

### Лексер (lexer.py)
Лексер выполняет токенизацию входного текста, разбивая его на лексемы (токены).

#### Основные классы:
- `Lexer` - основной класс лексера
- `LexerException` - исключение лексера
- `TokenType` - перечисление типов токенов
- `Token` - класс токена

#### Поддерживаемые токены:
- Идентификаторы и переменные
- Логические операторы (`&`, `|`, `!`, `->`, `<->`)
- Арифметические операторы (`+`, `-`, `*`, `/`)
- Операторы сравнения (`>`, `<`, `>=`, `<=`, `==`, `!=`)
- Скобки и разделители
- Комментарии
- Команды

### Парсер (parser.py)
Парсер строит абстрактное синтаксическое дерево (AST) из последовательности токенов.

#### Основные классы:
- `Parser` - основной класс парсера
- `ParserException` - исключение парсера
- `ASTNode` и его наследники - узлы AST

#### Поддерживаемые конструкции:
- Высказывания
- Предикаты с аргументами
- Логические выражения с приоритетами операций
- Арифметические выражения
- Аксиомы (импликации)
- Теоремы (запросы)
- Команды

### AST трансформер (ast_transformer.py)
AST трансформер преобразует AST в модели данных, используемые логическим движком.

#### Основные классы:
- `ASTTransformer` - основной класс трансформера
- `ASTTransformerException` - исключение трансформера

#### Преобразования:
- Высказывания → `Predicate`
- Предикаты → `Predicate` с аргументами
- Логические операции → соответствующие классы (`Conjunction`, `Disjunction`, и т.д.)
- Арифметические операции → соответствующие классы (`Addition`, `Subtraction`, и т.д.)
- Сравнения → соответствующие классы (`GreaterThan`, `LessThan`, и т.д.)

### Модели данных (models.py)
Модели данных представляют логические выражения в памяти.

#### Основные классы:
- `Predicate` - предикат (высказывание или предикат с аргументами)
- `Variable` - переменная
- `Term` - терм
- `Operation` - базовый класс для операций
- `Conjunction`, `Disjunction`, `Negation`, `Implication`, `Equivalence` - логические операции
- `Addition`, `Subtraction`, `Multiplication`, `Division` - арифметические операции
- `GreaterThan`, `LessThan`, `GreaterThanOrEqual`, `LessThanOrEqual`, `Equal`, `NotEqual` - сравнения
- `Disjunct` - дизъюнкт (дизъюнкция литералов)
- `CNF` - конъюнктивная нормальная форма

### Унификация (unification.py)
Унификация реализует алгоритм Робинсона для нахождения подстановки, делающей два предиката идентичными.

#### Основные классы:
- `Substitution` - подстановка переменных
- `UnificationException` - исключение унификации

#### Основные функции:
- `unify` - алгоритм унификации Робинсона
- `unify_list` - унификация списка предикатов
- `occurs_check` - проверка вхождения переменной

### Логический движок (engine.py)
Логический движок реализует метод резолюций и преобразование выражений в конъюнктивную нормальную форму.

#### Основные классы:
- `LogicalEngine` - основной класс движка
- `EngineError` - исключение движка

#### Основные методы:
- `add_axiom` - добавление аксиомы в базу знаний
- `resolution_method` - метод резолюций
- `resolution_method_with_unification` - метод резолюций с унификацией
- `to_cnf` - преобразование в КНФ
- `remove_implications`, `remove_equivalences`, `remove_double_negations`, `apply_de_morgan`, `group_conjunctions` - шаги преобразования в КНФ

### Команды (commands.py)
Команды обрабатывают пользовательские команды интерфейса.

#### Основные классы:
- `Command` - базовый класс команды
- `LoadCommand`, `GetAxiomsCommand`, `RemoveCommand`, `HelpCommand` - конкретные команды
- `CommandProcessor` - процессор команд
- `CommandException` - исключение команд

### REPL (repl.py)
REPL (Read-Eval-Print Loop) предоставляет интерактивный интерфейс пользователя.

#### Основные классы:
- `REPL` - основной класс REPL
- `REPLError` - исключение REPL

## Поток данных

1. **Ввод пользователя** → Лексер → **Токены**
2. **Токены** → Парсер → **AST**
3. **AST** → AST трансформер → **Модели данных**
4. **Модели данных** → Логический движок → **Результат**
5. **Результат** → REPL → **Вывод пользователю**

## Метод резолюций

SHLDN использует метод резолюций для доказательства теорем:

1. Все аксиомы преобразуются в конъюнктивную нормальную форму (КНФ)
2. Теорема отрицается и также преобразуется в КНФ
3. Применяется правило резолюций для нахождения пустого дизъюнкта
4. Если пустой дизъюнкт найден, теорема доказана

## Унификация переменных

SHLDN поддерживает унификацию переменных в предикатах:

1. При резолюции проверяется, могут ли два литерала быть унифицированы
2. Если могут, применяется алгоритм унификации Робинсона
3. Найденная подстановка применяется к резольвенте

## Обработка арифметических выражений

SHLDN поддерживает арифметические выражения в предикатах:

1. Арифметические выражения парсятся как часть предикатов
2. При резолюции арифметические выражения обрабатываются как составные термы
3. Для доказательства теорем с арифметикой требуется точное совпадение выражений

## Расширяемость

Архитектура SHLDN позволяет легко расширять функциональность:

1. **Добавление новых операций** - создание новых классов операций и их обработка в парсере и движке
2. **Добавление новых команд** - создание новых классов команд и их регистрация в процессоре команд
3. **Изменение логики резолюций** - модификация методов логического движка
4. **Добавление новых типов выражений** - расширение моделей данных и соответствующих трансформаций

## Тестирование

Проект имеет полное покрытие тестами:

- **Тесты лексера** - проверка токенизации различных конструкций
- **Тесты парсера** - проверка построения AST
- **Тесты AST трансформера** - проверка преобразования AST в модели данных
- **Тесты унификации** - проверка алгоритма унификации
- **Тесты логического движка** - проверка методов преобразования и резолюции
- **Тесты команд** - проверка обработки команд
- **Тесты REPL** - проверка интерактивного интерфейса
- **Интеграционные тесты** - проверка работы всей системы

## Производительность

SHLDN оптимизирован для работы с небольшими и средними базами знаний. Для больших баз знаний могут потребоваться дополнительные оптимизации:

- Кэширование результатов унификации
- Индексация аксиом для быстрого поиска
- Оптимизация алгоритма резолюций